# Ray.Di

> Ray.Di is a PHP dependency injection framework inspired by Google Guice. It automatically resolves object dependencies and enables flexible, testable code through compile-time dependency resolution.

Ray.Di has been actively maintained since 2015, supporting PHP 7.2+ with a focus on performance and developer experience. It uses code generation to minimize runtime overhead while providing powerful features like aspect-oriented programming (AOP).

## Why Ray.Di?

- **Compile-time safety**: Detects configuration errors before runtime
- **Zero annotations**: Constructor injection works without special markers
- **Performance optimized**: Generates efficient code for production
- **Framework agnostic**: Integrates with any PHP application

## Essential Concepts

- [Bindings](/manuals/1.0/en/Bindings.md): Learn how to wire interfaces to implementations
- [Scopes](/manuals/1.0/en/Scopes.md): Control object lifecycles with Singleton and Prototype scopes
- [Modules](/manuals/1.0/en/GettingStarted.md): Organize your bindings into reusable configuration units

## Common Binding Patterns

- [Linked Bindings](/manuals/1.0/en/LinkedBindings.md): The most common pattern - bind an interface to a concrete class
- [Provider Bindings](/manuals/1.0/en/ProviderBindings.md): Create objects with complex initialization logic
- [Instance Bindings](/manuals/1.0/en/InstanceBindings.md): Bind to pre-existing objects or values
- [Constructor Bindings](/manuals/1.0/en/ConstructorBindings.md): Select specific constructors for injection

## Advanced Techniques

- [AOP](/manuals/1.0/en/AOP.md): Intercept method calls for logging, transactions, and security
- [Contextual Bindings](/manuals/1.0/en/ContextualBindings.md): Different implementations for different use cases
- [Injecting Providers](/manuals/1.0/en/InjectingProviders.md): Lazy loading and multiple instances
- [Multibindings](/manuals/1.0/en/Multibindings.md): Create plugin systems with sets and maps

## Production Ready

- [Performance Boost](/manuals/1.0/en/PerformanceBoost.md): Use ScriptInjector for 10x faster production performance
- [Integration](/manuals/1.0/en/Integration.md): Works with Laravel, Symfony, and other frameworks
- [Backward Compatibility](/manuals/1.0/en/BackwardCompatibility.md): Semantic versioning with no BC breaks in minor versions

## Optional

- [All Best Practices](/manuals/1.0/en/BestPractices.md): Comprehensive guide to Ray.Di best practices
- [Grapher](/manuals/1.0/en/Grapher.md): Visualize your dependency graph
- [Additional Binding Types](/manuals/1.0/en/BindingAttributes.md): Qualifiers, untargeted bindings, and more
- [Object Lifecycle](/manuals/1.0/en/ObjectLifeCycle.md): PostConstruct and other lifecycle hooks
- [Injections](/manuals/1.0/en/Injections.md): Method, setter, and assisted injection patterns

## Getting Started

- [Installation](#installation):  Quick setup with Composer - `composer require ray/di`
- [Overview](#overview):  Core concepts and architecture of dependency injection
- [Tutorial](#tutorial1):  Build your first Ray.Di application step-by-step
- [Mental Model](#mentalmodel):  Think of Ray.Di as a map from types to their providers

## Best Practices

- [Minimize Mutability](#minimizemutability):  Prefer constructor injection for immutable, thread-safe objects
- [Inject Only Direct Dependencies](#injectonlydirectdependencies):  Don't inject factories just to get other objects
- [Organize Modules by Feature](#organizemodulesbyfeature):  Group related bindings together, not by type
- [Avoid Static State](#avoidstaticstate):  Static state makes testing difficult and should be injected instead

---

1---
layout: docs-en
title: Installation
category: Manual
permalink: /manuals/1.0/en/installation.html
---
# Installation

The recommended way to install Ray.Di is through [Composer](https://github.com/composer/composer).

```bash
composer require ray/di ^2.0
```

The GitHub repository is at [ray-di/Ray.Di](https://github.com/ray-di/Ray.Di)

## Testing Ray.Di

Here's how to install Ray.Di from source and run the unit tests and demos.

```bash
git clone https://github.com/ray-di/Ray.Di.git
cd Ray.Di
./vendor/bin/phpunit
php demo-php8/run.php
```

<img src="/images/logo.svg" alt="Ray.Di logo" width="200" height="200">

# Overview

Ray.Di is a dependency injection (DI) framework for PHP. It automatically resolves object dependencies and enables flexible object graph construction according to the context.

## Core Features

### Dependency Resolution at Compile Time

- Resolves dependencies by describing overall rules rather than individual object assembly (autowiring)
- Detects dependency issues before execution
- Minimizes runtime overhead through code generation

### Flexible Object Graph Construction

- Enables various contexts through the combination of independent modules
- Allows dependency resolution according to the injected object; for example, changing dependencies based on the target method's attributes or the object's state (CDI: Contexts and Dependency Injection)
- Injects different implementations of the same interface using `Qualifier`
- Supports injection of lazily instantiated objects

### Explicit Dependency Description

- Describes dependency generation using raw PHP code
- Utilizes attributes for self-documented dependency definitions
- Separates cross-cutting concerns through integration with AOP

## Stability and Reliability

Since the release of version 2.0 in 2015, Ray.Di has expanded its features along with the evolution of PHP while maintaining backward compatibility by following semantic versioning.

## Google Guice and Ray.Di

Ray.Di is a PHP DI framework inspired by [Google Guice](https://github.com/google/guice). Based on the proven API design of Google Guice, it aims for PHP-like evolution. Most of the documents on this site are also quoted from Google Guice.

---

Using dependency injection offers many benefits, but doing it manually requires writing a lot of boilerplate code. Ray.Di is a framework that allows you to use dependency injection without writing such cumbersome code. For more details, please see the [Motivation](motivation.html) page.

In short, Ray.Di eliminates the need to use factories or `new` in your PHP code. While you may still need to write factories, your code does not directly depend on them. Your code becomes easier to modify, unit test, and reuse in other contexts.

# Ray.Di Tutorial 1
In this tutorial, you will learn the basics of the DI pattern and how to start a Ray.Di project. We will change from a non-di code to a manual DI code, then to a code using Ray.Di to add functionality.

## Preparation
Create a project for the tutorial.



```
mkdir ray-tutorial
cd ray-tutorial
composer self-update
composer init --name=ray/tutorial --require=ray/di:^2 --autoload=src -n
composer update
```

Create `src/Greeter.php`.
A program that greets `$users` one after another.

```php
<?php
namespace Ray\Tutorial;

class Greeter
{
    public function sayHello(): void
    {
        $users = ['DI', 'AOP', 'REST'];
        foreach ($users as $user) {
            echo 'Hello ' . $user . '!' . PHP_EOL;
        }
    }
}
```

Prepare a script in `bin/run.php` to run it.

```php
<?php
use Ray\Tutorial\Greeter;

require dirname(__DIR__) . '/vendor/autoload.php';

(new Greeter)->sayHello();
```

Let's run it.

```php
php bin/run.php

Hello DI!
Hello AOP!
Hello REST!
```

## Dependency pull

Consider making `$users` variable.

For example, a global variable?

```diff
-       $users = ['DI', 'AOP', 'REST'];
+       $users = $GLOBALS['users'];
```

Too wild. Let's consider other ways.

```php
define("USERS", ['DI', 'AOP', 'REST']);

$users = USERS;
```
```php
class User
{
    public const NAMES = ['DI', 'AOP', 'REST'];
};

$users = User::NAMES;
```

```php
$users = Config::get('users')
```

It is getting the necessary dependencies from the outside, It's "dependency pull" and in the end it is the same global as the `$GLOBALS` variable. It makes the coupling between objects tight and difficult to test.

## Dependency Injection

The DI pattern is one in which dependencies are injected from other sources, rather than being obtained from the code itself.

```php
class Greeter
{
    public function __construct(
        private readonly Users $users
    ) {}

    public function sayHello(): void
    {
        foreach ($this->users as $user) {
            echo 'Hello ' . $user . '!' . PHP_EOL;
        }
    }
}
```

Inject not only the data you need, but also the output as a separate service.

```diff
    public function __construct(
-       private readonly Users $users
+       private readonly Users $users,
+       private readonly PrinterInterface $printer
    ) {}

    public function sayHello()
    {
        foreach ($this->users as $user) {
-            echo 'Hello ' . $user . '!' . PHP_EOL;
+            ($this->printer)($user);
        }
    }
```

Create the following classes

`src/Users.php`

```php
<?php
namespace Ray\Tutorial;

use ArrayObject;

final class Users extends ArrayObject
{
}
```

`src/PrinterInterface.php`

```php
<?php
namespace Ray\Tutorial;

interface PrinterInterface
{
    public function __invoke(string $user): void;
}
```

`src/Printer.php`

```php
<?php
namespace Ray\Tutorial;

class Printer implements PrinterInterface
{
    public function __invoke(string $user): void
    {
        echo 'Hello ' . $user . '!' . PHP_EOL;
    }
}
```

`src/GreeterInterface.php`

```php
<?php
namespace Ray\Tutorial;

interface GreeterInterface
{
    public function sayHello(): void;
}
```

`src/CleanGreeter.php`

```php
<?php
namespace Ray\Tutorial;

class CleanGreeter implements GreeterInterface
{
    public function __construct(
        private readonly Users $users,
        private readonly PrinterInterface $printer
    ) {}

    public function sayHello(): void
    {
        foreach ($this->users as $user) {
            ($this->printer)($user);
        }
    }
}
```

## Manual DI

Create and run a script `bin/run_di.php` to do this.

```php
<?php

use Ray\Tutorial\CleanGreeter;
use Ray\Tutorial\Printer;
use Ray\Tutorial\Users;

require dirname(__DIR__) . '/vendor/autoload.php';

$greeter = new CleanGreeter(
    new Users(['DI', 'AOP', 'REST']),
    new Printer
);

$greeter->sayHello();
```

While the number of files may seem to increase in number and overall complexity, the individual scripts are so simple that it is difficult to make them any simpler. Each class has only one responsibility [^srp], relies on abstractions rather than implementations [^dip], and is easy to test, extend, and reuse.

[^srp]: [Single Responsibility Principle (SRP)](https://ja.wikipedia.org/wiki/SOLID)
[^dip]: [Dependency Inversion Principle (DIP)](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E9%80%86%E8%BB%A2%E3%81%AE%E5%8E%9F%E5%89%87)

### Compile Time and Runtime

Code under `bin/` constitutes a dependency at **compile time**, while code under `src/` is executed at **run time**. PHP is a scripting language, but this distinction between compile time and run time can be considered.

### Constructor Injection

DI code passes dependencies externally and receives them in the constructor.

```php
$instance = new A(
    new B,
    new C(
        new D(
            new E, new F, new G
        )
    )
);
```

B and C needed to generate A are passed to the constructor from outside A (without being obtained from inside A); D to generate C, E,F,G to generate D... and dependencies require other dependencies, and objects generate an object graph [^og] containing dependent objects.

As the size of the project grows, manual DI using such factory code becomes a reality with problems such as deep nested dependency resolution, instance management such as singletons, reusability, and maintainability. Ray.Di solves that dependency problem.

[^og]: "In computer science, object-oriented applications have a complex network of interrelated objects. Objects are connected to each other either by being owned by one object or by containing other objects (or their references). This object net is called an object graph." [Object Graph](https://en.wikipedia.org/wiki/Object_graph)

### Module

A module is a set of bindings. There are several types of binding, but here we will use the most basic, link binding, which binds an interface to a class, and instance binding, which binds to an actual instance, such as a value object.

Create `src/AppModule.php`.

```php
<?php
namespace Ray\Tutorial;

use Ray\Di\AbstractModule;

class AppModule extends AbstractModule
{
    protected function configure(): void
    {
        $this->bind(Users::class)->toInstance(new Users(['DI', 'AOP', 'REST']));
        $this->bind(PrinterInterface::class)->to(Printer::class);
        $this->bind(GreeterInterface::class)->to(CleanGreeter::class);
    }
}
```

Create and run `bin/run_di.php` to run.

```php
<?php

use Ray\Di\Injector;
use Ray\Tutorial\AppModule;
use Ray\Tutorial\GreeterInterface;

require dirname(__DIR__) . '/vendor/autoload.php';

$module = new AppModule();
$injector = new Injector($module);
$greeter = $injector->getInstance(GreeterInterface::class);
$greeter->sayHello();
```

Did it work? If something is wrong, please compare it with [tutorial1](https://github.com/ray-di/tutorial1/tree/master/src).

## Dependency Replacement

Sometimes you want to change the bindings depending on the context of execution, such as only for unit testing, only for development, and so on.

For example, suppose you have a test-only binding `src/TestModule.php`.

```php
<?php

namespace Ray\Tutorial;

use Ray\Di\AbstractModule;

final class TestModule extends AbstractModule
{
    protected function configure(): void
    {
        $this->bind(Users::class)->toInstance(new Users(['TEST1', 'TEST2']));
    }
}
```

Modify the `bin/run_di.php` script to override this binding.

```diff
use Ray\Tutorial\AppModule;
+use Ray\Tutorial\TestModule;
use Ray\Tutorial\GreeterInterface;

require dirname(__DIR__) . '/vendor/autoload.php';

$module = new AppModule();
+$module->override(new TestModule());
```

Let's run it.

```
Hello TEST1!
Hello TEST2!
```

## Dependency on Dependency

Next, the greeting message, which is now fixed and retained in the Printer, is also changed to be injected to support multiple languages.

Create `src/IntlPrinter.php`.

```php
<?php
namespace Ray\Tutorial;

use Ray\Di\Di\Named;

class IntlPrinter implements PrinterInterface
{
    public function __construct(
        #[Message] private string $message
    ){}

    public function __invoke(string $user): void
    {
        printf($this->message, $user);
    }
}
```

The constructor takes a message string for the greeting, but to identify this bundle [attribute bundle](https://ray-di.github.io/manuals/1.0/ja/binding_attributes.html) for the `#[Message]`attribute, `src/Message.php`.

```php
<?php
namespace Ray\Tutorial;

use Attribute;
use Ray\Di\Di\Qualifier;

#[Attribute, Qualifier]
class Message
{
}
```

Change the binding.

```diff
class AppModule extends AbstractModule
{
    protected function configure(): void
    {
        $this->bind(Users::class)->toInstance(new Users(['DI', 'AOP', 'REST']));
-       $this->bind(PrinterInterface::class)->to(Printer::class);
+       $this->bind(PrinterInterface::class)->to(IntlPrinter::class);
+       $this->bind()->annotatedWith(Message::class)->toInstance('Hello %s!' . PHP_EOL);
        $this->bind(GreeterInterface::class)->to(CleanGreeter::class);
    }
}
```

Run it to make sure it does not change.

Then try the error. Comment out the `Message::class` binding in the `configure()` method.

```diff
-        $this->bind()->annotatedWith(Message::class)->toInstance('Hello %s!' . PHP_EOL);
+        // $this->bind()->annotatedWith(Message::class)->toInstance('Hello %s!' . PHP_EOL);
```

This means that Ray.Di does not know what to inject into the dependencies attributed as `#[Message]`.

When I run it, I get the following error

```
PHP Fatal error:  Uncaught exception 'Ray\Di\Exception\Unbound' with message '-Ray\Tutorial\Message'
- dependency '' with name 'Ray\Tutorial\Message' used in /tmp/tutorial/src/IntlPrinter.php:8 ($message)
- dependency 'Ray\Tutorial\PrinterInterface' with name '' /tmp/tutorial/src/CleanGreeter.php:6 ($printer)
```

This is an error that `$message` in `IntlPrinter.php:8` cannot resolve its dependency, so `$printer` in `CleanGreeter.php:6` which depends on it also cannot resolve its dependency and the injection failed. Thus, when a dependency of a dependency cannot be resolved, the nesting of that dependency is also displayed.

Finally, let's create the following bundle as `src/SpanishModule.php` and overwrite it in the same way as TestModule.

```php
<?php
namespace Ray\Tutorial;

use Ray\Di\AbstractModule;

class SpanishModule extends AbstractModule
{
    protected function configure(): void
    {
        $this->bind()->annotatedWith(Message::class)->toInstance('¡Hola %s!' . PHP_EOL);
    }
}
```

```diff
use Ray\Tutorial\AppModule;
-use Ray\Tutorial\TestModule;
+use Ray\Tutorial\SpanishModule;
use Ray\Tutorial\GreeterInterface;

require dirname(__DIR__) . '/vendor/autoload.php';

$module = new AppModule();
-$module->override(new TestModule());
+$module->override(new SpanishModule());
```

Have you changed to the Spanish greeting as follows?

```
¡Hola DI!
¡Hola AOP!
¡Hola REST!
```

## Summary

We have seen the basics of the DI pattern and Ray.Di.
Dependencies are injected recursively from the outside rather than obtained by user code from within, and an object graph is generated.

At compile time, the relationship building between objects through dependency binding is complete, and at the runtime, the running code depends only on the interface. By following the DI pattern, the SRP principle [^srp] and the DIP principle [^dip] can be followed by nature.

The responsibility of securing dependencies has been removed from the code, making it loosely coupled and simple. The code is stable yet flexible, open to extensions but closed to modifications. [^ocp]

[^ocp]: [OCP](https://ja.wikipedia.org/wiki/%E9%96%8B%E6%94%BE/%E9%96%89%E9%8E%96%E5%8E%9F%E5%89%87)
¥
---

# Ray.Di Mental Model

_Learn about `Key`, `Provider` and how Ray.Di is just a map_

When you are reading about "Dependency Injection", you often see many buzzwords ("Inversion of
control", "Hollywood principle") that make it sound confusing. But
underneath the jargon of dependency injection, the concepts aren't very
complicated. In fact, you might have written something very similar already!
This page walks through a simplified model of Ray.Di implementation, which
should make it easier to think about how it works.



## Ray.Di is a map

Fundamentally, Ray.Di helps you create and retrieve objects for your application
to use. These objects that your application needs are called **dependencies**.

You can think of Ray.Di as being a map[^Ray.Di-map]. Your application code
declares the dependencies it needs, and Ray.Di fetches them for you from its map.
Each entry in the "Ray.Di map" has two parts:

*   **Ray.Di key**: a key in the map which is used to fetch a particular value
    from the map.
*   **Provider**: a value in the map which is used to create objects for your
    application.

Ray.Di keys and Providers are explained below.

[^Ray.Di-map]: The actual implementation of Ray.Di is far more complicated, but a
map is a reasonable approximation for how Ray.Di behaves.

### Ray.Di keys

Ray.Di uses `Key` to identify a dependency that can be resolved using the
"Ray.Di map".

The `Greeter` class used in the [Getting Started](#gettingstarted) declares two
dependencies in its constructor and those dependencies are represented as `Key`
in Ray.Di:

*   `#[Message] string` --> `$map[$messageKey]`
*   `#[Count] int` --> `$map[$countKey]`

The simplest form of a `Key` represents a type in php:

```php
// Identifies a dependency that is an instance of string.
/** @var string $databaseKey */
$databaseKey = $map[$key];
```

However, applications often have dependencies that are of the same type:

```php
class Message
{
    public function __construct(
    	  public readonly string $text
    ){}
}

class MultilingualGreeter
{
    public function __construct(
      private readonly Message $englishGreeting,
      private readonly Message $spanishGreeting
    ) {}
}
```

Ray.Di uses [binding attributes](#bindingattributes) to distinguish dependencies
that are of the same type, that is to make the type more specific:

```php
class MultilingualGreeter
{
    public function __construct(
      #[English] private readonly Message $englishGreeting,
      #[Spanish] private readonly Message $spanishGreeting
    ) {}
}
```

`Key` with binding attribute can be created as:

```php
$englishGreetingKey = $map[Message::class . English::class];
$spanishGreetingKey = $map[Message::class . Spanish::class];
```

When an application calls `$injector->getInstance(MultilingualGreeter::class)` to
create an instance of `MultilingualGreeter`. This is the equivalent of doing:

```php
// Ray.Di internally does this for you so you don't have to wire up those
// dependencies manually.
$english = $injector->getInstance(Message::class, English::class));
$spanish = $injector->getInstance(Message::class, Spanish::class));
$greeter = new MultilingualGreeter($english, $spanish);
```

To summarize: **Ray.Di `Key` is a type combined with an optional binding
attribute used to identify dependencies.**

### Ray.Di `Provider`s

Ray.Di uses
[`Provider`](https://google.github.io/Ray.Di/api-docs/latest/javadoc/com/google/inject/Provider.html)
to represent factories in the "Ray.Di map" that are capable of creating objects
to satisfy dependencies.

`Provider` is an interface with a single method:

```php
interface Provider
{
  /** Provides an instance/
  public function get();
}
```

Each class that implements `Provider` is a bit of code that knows how to give
you an instance of `T`. It could call `new T()`, it could construct `T` in some
other way, or it could return you a precomputed instance from a cache.

Most applications do not implement `Provider` interface directly, they use
`Module` to configure Ray.Di injector and Ray.Di injector internally creates
`Provider`s for all the object it knows how to create.

For example, the following Ray.Di module creates two `Provider`s:

```php
class countProvicer implements ProviderInterface
{
    public function get(): int
    {
        return 3;
    }
}

class messageProvider implements ProviderInterface
{
    public function get(): Message
    {
        return new Message('hello world');
    }
}

class DemoModule extends AbstractModule
{
   protected function configure(): void
   {
       $this->bind()->annotatedWith(Count::class)->toProvider(CountProvicer::class);
       $this->bind()->annotatedWith(Message::class)->toProvider(MessageProvicer::class);
   }
}
```

*   `MessageProvicer` that calls the `get()` method and returns "hello
    world"
*   `CountProvicer` that calls the `get()` method and returns `3`

## Using Ray.Di

There are two parts to using Ray.Di:

1.  **Configuration**: your application adds things into the "Ray.Di map".
1.  **Injection**: your application asks Ray.Di to create and retrieve objects
    from the map.

Configuration and injection are explained below.

### Configuration

Ray.Di maps are configured using Ray.Di modules. A **Ray.Di module** is a unit of
configuration logic that adds things into the Ray.Di map. There are two ways to
do this:

*   Using the Ray.Di Domain Specific Language (DSL).

Conceptually, these APIs simply provide ways to manipulate the Ray.Di map. The
manipulations they do are pretty straightforward. Here are some example
translations, shown using PHP syntax for brevity and clarity:

| Ray.Di DSL syntax                   | Mental model                                                                       |
| ---------------------------------- | ---------------------------------------------------------------------------------- |
| `bind($key)->toInstance($value)`  | `$map[$key] = $value;`  <br>(instance binding)          |
| `bind($key)->toProvider($provider)` | `$map[$key] = fn => $value;` <br>(provider  binding) |
| `bind(key)->to(anotherKey)`       | `$map[$key] = $map[$anotherKey];` <br>(linked binding) |

`DemoModule` adds two entries into the Ray.Di map:

*   `#[Message] string` --> `fn() => (new MessageProvicer)->get()`
*   `#[Count] int` --> `fn() => (new CountProvicer)->get()`

### Injection

You don't *pull* things out of a map, you *declare* that you need them. This is
the essence of dependency injection. If you need something, you don't go out and
get it from somewhere, or even ask a class to return you something. Instead, you
simply declare that you can't do your work without it, and rely on Ray.Di to give
you what you need.

This model is backwards from how most people think about code: it's a more
*declarative* model rather than an *imperative* one. This is why dependency
injection is often described as a kind of *inversion of control* (IoC).

Some ways of declaring that you need something:

1. An argument to a constructor:

    ```php
    class Foo
    {
      // We need a database, from somewhere
      public function __construct(
            private Database $database
       ) {}
    }
    ```

2. An argument to a `DatabaseProvider::get()` method:

    ```php
    class DatabaseProvider implements ProviderInterface
    {
        public function __construct(
            #[Dsn] private string $dsn
        ){}
      
        public function get(): Database
        {
            return new Database($this->dsn);
        }
    }
    ```

This example is intentionally the same as the example `Foo` class from
[Getting Started Guide](GettingStarted#what-is-dependency-injection).
Unlike Guice, Ray.Di does not require the `Inject` attribute to be added to the constructor.

## Dependencies form a graph

When injecting a thing that has dependencies of its own, Ray.Di recursively
injects the dependencies. You can imagine that in order to inject an instance of
`Foo` as shown above, Ray.Di creates `Provider` implementations that look like
these:

```php
class FooProvider implements Provider
{
    public function get(): Foo
    {
        global $map;
        
        $databaseProvider = $map[Database::class]);
        $database = $databaseProvider->get();
        
        return new Foo($database);
    }
}

class DatabaseProvider implements Provider
{
    public function get(): Database
    {
        global $map;
        
        $dsnProvider = $map[Dsn::class];
        $dsn = $dsnProvider->get();
        
        return new Database($dsn);
    }
}  

class DsnProvider implements Provider
{
    public function get(): string
    {
        return getenv(DB_DSN);
    }
}  
```

Dependencies form a *directed graph*, and injection works by doing a depth-first
traversal of the graph from the object you want up through all its dependencies.

A Ray.Di `Injector` object represents the entire dependency graph. To create an
`Injector`, Ray.Di needs to validate that the entire graph works. There can't be
any "dangling" nodes where a dependency is needed but not provided.[^3]
If the bound is incomplete somewhere in the graph, Ray.Di will throw an `Unbound` exception.

[^3]: The reverse case is not an error: it's fine to provide something even if
nothing ever uses it—it's just dead code in that case. That said, just
like any dead code, it's best to delete providers if nobody uses them
anymore.

## What's next?

Learn how to use [`Scopes`](scopes.html) to manage the lifecycle of objects created
by Ray.Di and the many different ways to
[add entries into the Ray.Di map](bindings.html).

# Minimize mutability

Wherever possible, use constructor injection to create immutable objects.
Immutable objects are simple, shareable, and can be composed. Follow this
pattern to define your injectable types:

```php
class RealPaymentService implements PaymentServiceInterface
{
    public function __construct(
        private readnonly PaymentQueue $paymentQueue,
        private readnonly Notifier $notifier;
    ){}
```

All fields of this class are readonly and initialized by a constructor.

## Injecting methods

*Constructor injection* has some limitations:

*   Injected constructors may not be optional.
*   It cannot be used unless objects are created by Ray.Di.
*   Subclasses must call `parent()` with all dependencies. This makes constructor
    injection cumbersome, especially as the injected base class changes.

*Setter injection* is most useful when you need to initialize an instance that
is not constructed by Ray.Di.

# Inject only direct dependencies

Avoid injecting an object only as a means to get at another object. For example, don't inject a `Customer` as a means to get at an `Account`:

```php
class ShowBudgets
{
    private readonly Account $account;

    public function __construct(Customer $customer)
    {
        $this->account = $customer->getPurchasingAccount();
    }
```

Instead, inject the dependency directly. This makes testing easier; the test case doesn't need to concern itself with the customer. Use an `Provider` class to create the binding for `Account` that uses the binding for `Customer`:

```php
class CustomersModule extends AbstractModule
{
    protected function configure()
    {
        $this->bind(Account::class)->toProvider(PurchasingAccountProvider::class);
    }
}

class PurchasingAccountProvider implements ProviderInterface
{
    public function __construct(
        private readonly Customer $customer
    ) {}
    
    public function get(): Account
    {
        return $this->customer->getPurchasingAccount();
    }
}
```

By injecting the dependency directly, our code is simpler.

```php
class ShowBudgets
{
    public function __construct(
        private readonly Account $account
   ) {}
```

# Organize modules by feature, not by class type

Group bindings into features. Ideally it should be possible to enable/disable an
entire working feature by simply installing or not installing a single module in
the injector.

For example, don't just make a `FiltersModule` that has bindings for all the
classes that implement `Filter` in it, and a `GraphsModule` that has all the
classes that implement `Graph`, etc. Instead, try to organize modules by
feature, for example an `AuthenticationModule` that authenticates requests made
to your server, or a `FooBackendModule` that lets your server make requests to
the Foo backend.

This principle is also known as "organize modules vertically, not horizontally".

# Avoid static state

Static state and testability are enemies. Your tests should be fast and free of
side-effects. But non-constant values held by static fields are a pain to
manage. It's tricky to reliably tear down static singletons that are mocked by
tests, and this interferes with other tests.

Although *static state* is bad, there's nothing wrong with the static *keyword*.
Static classes are okay (preferred even!) and for pure functions (sorting, math,
etc.), static is just fine.
