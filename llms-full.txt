# Ray.Di

> Ray.Di is a PHP dependency injection framework inspired by Google Guice. It provides a powerful and flexible way to manage dependencies in your PHP applications through constructor injection, setter injection, and assisted injection.

Ray.Di is a mature framework that has been actively maintained since 2015, supporting the latest PHP versions while maintaining backward compatibility. It follows the dependency injection pattern to create loosely coupled, testable, and maintainable code.

## Core Concepts

- **Dependency Injection**: Dependencies are injected from outside rather than created internally
- **Modules**: Configuration units that define how dependencies are resolved
- **Bindings**: Map interfaces to their implementations
- **Scopes**: Control the lifecycle of injected objects (Singleton, Prototype)
- **AOP Support**: Aspect-oriented programming for cross-cutting concerns

## Key Features

- Constructor injection without annotations
- Method injection with #[Inject] attribute
- Assisted injection for runtime dependencies
- Provider pattern support for lazy loading
- Contextual bindings for different implementations
- Built-in AOP support for method interception
- Multi-bindings for plugin architectures

## Getting Started

- [Overview](/manuals/1.0/en/Overview.md): Overview of Ray.Di framework
- [Motivation](/manuals/1.0/en/Motivation.md): Why use dependency injection
- [Getting Started](/manuals/1.0/en/GettingStarted.md): Introduction to dependency injection with Ray.Di
- [Installation](/manuals/1.0/en/Installation.md): How to install Ray.Di via Composer
- [Mental Model](/manuals/1.0/en/MentalModel.md): Understanding Ray.Di as a map of keys to providers
- [Tutorial](/manuals/1.0/en/Tutorial1.md): Step-by-step guide from manual DI to Ray.Di

## Core Features

- [Bindings](/manuals/1.0/en/Bindings.md): Core binding concepts
- [Scopes](/manuals/1.0/en/Scopes.md): Managing object lifecycles
- [Injections](/manuals/1.0/en/Injections.md): Different injection types

## Binding Types

- [Linked Bindings](/manuals/1.0/en/LinkedBindings.md): Map interfaces to implementations
- [Instance Bindings](/manuals/1.0/en/InstanceBindings.md): Bind to specific instances
- [Provider Bindings](/manuals/1.0/en/ProviderBindings.md): Use providers for complex object creation
- [Constructor Bindings](/manuals/1.0/en/ConstructorBindings.md): Bind to specific constructors
- [Untargeted Bindings](/manuals/1.0/en/UntargetedBindings.md): Bindings without specific targets
- [Binding Attributes](/manuals/1.0/en/BindingAttributes.md): Use qualifiers for multiple bindings of same type
- [Builtin Bindings](/manuals/1.0/en/BuiltinBindings.md): Built-in bindings provided by Ray.Di
- [Null Object Binding](/manuals/1.0/en/NullObjectBinding.md): Null object pattern support

## Performance & Tools

- [Performance Boost](/manuals/1.0/en/PerformanceBoost.md): ScriptInjector and CachedInjector for production optimization
- [Grapher](/manuals/1.0/en/Grapher.md): Visualize object graphs and dependencies
- [Integration](/manuals/1.0/en/Integration.md): Integrating Ray.Di with other frameworks

## Additional Resources

- [Backward Compatibility](/manuals/1.0/en/BackwardCompatibility.md): Ray.Di's commitment to not breaking BC

## Advanced Features

- [AOP](/manuals/1.0/en/AOP.md): Method interception for cross-cutting concerns
- [Injecting Providers](/manuals/1.0/en/InjectingProviders.md): Inject providers for multiple instances and lazy loading
- [Multibindings](/manuals/1.0/en/Multibindings.md): Support for plugin architectures
- [Contextual Bindings](/manuals/1.0/en/ContextualBindings.md): Different implementations based on context
- [Object Life Cycle](/manuals/1.0/en/ObjectLifeCycle.md): PostConstruct for initialization after injection

## Best Practices

- [Best Practices Overview](/manuals/1.0/en/BestPractices.md): Overview of Ray.Di best practices
- [Minimize Mutability](/manuals/1.0/en/bp/MinimizeMutability.md): Use constructor injection for immutable objects
- [Inject Only Direct Dependencies](/manuals/1.0/en/bp/InjectOnlyDirectDependencies.md): Avoid injecting objects to get other objects
- [Avoid Static State](/manuals/1.0/en/bp/AvoidStaticState.md): Static state and testability are enemies
- [Organize Modules by Feature](/manuals/1.0/en/bp/OrganizeModulesByFeature.md): Group bindings by feature, not by type
- [Avoid Conditional Logic in Modules](/manuals/1.0/en/bp/AvoidConditionalLogicInModules.md): Keep modules simple and predictable
- [Modules Should Be Fast and Side Effect Free](/manuals/1.0/en/bp/ModulesShouldBeFastAndSideEffectFree.md): Module configuration best practices
- [Document Public Bindings](/manuals/1.0/en/bp/DocumentPublicBindings.md): Documentation practices for bindings
- [Don't Reuse Annotations](/manuals/1.0/en/bp/DontReuseAnnotations.md): Create specific annotations for each binding
- [Injecting the Injector](/manuals/1.0/en/bp/InjectingTheInjector.md): When and how to inject the injector
- [Cyclic Dependencies](/manuals/1.0/en/bp/CyclicDependencies.md): Handling circular dependencies

---

# Aspect Oriented Programing
_Intercepting methods with Ray.Di_

To complement dependency injection, Ray.Di supports *method interception*. This feature enables you to write code that is executed each time a _matching_ method is invoked. It's suited for cross cutting concerns ("aspects"), such as transactions, security and logging. Because interceptors divide a problem into aspects rather than objects, their use is called Aspect Oriented Programming (AOP).

[Matcher](https://github.com/ray-di/Ray.Aop/blob/2.x/src/MatcherInterface.php) is a simple interface that either accepts or rejects a value. For Ray.Di AOP, you need two matchers: one that defines which classes participate, and another for the methods of those classes. 

[MethodInterceptors](https://github.com/ray-di/Ray.Aop/blob/2.x/src/MethodInterceptor.php) are executed whenever a matching method is invoked. They have the opportunity to
inspect the call: the method, its arguments, and the receiving instance. They can perform their cross-cutting logic and then delegate to the underlying method. Finally, they may inspect the return value or exception and return. Since interceptors may be applied to many methods and will receive many calls, their implementation should be efficient and unintrusive.

## Example: Forbidding method calls on weekends

To illustrate how method interceptors work with Ray.Di, we'll forbid calls to our pizza billing system on weekends. The delivery guys only work Monday thru Friday so we'll prevent pizza from being ordered when it can't be delivered! This example is structurally similar to use of AOP for authorization.

To mark select methods as weekdays-only, we define an attribute:

```php
#[Attribute(Attribute::TARGET_METHOD)]
final class NotOnWeekends
{
}
```

...and apply it to the methods that need to be intercepted:

```php
class BillingService implements BillingServiceInterface
{
    #[NotOnWeekends]
    public function chargeOrder(PizzaOrder $order, CreditCard $creditCard)
    {
```

Next, we define the interceptor by implementing the `MethodInterceptor` interface. When we need to call through to the underlying method, we do so by calling `$invocation->proceed()`:

```php

use Ray\Aop\MethodInterceptor;
use Ray\Aop\MethodInvocation;

class WeekendBlocker implements MethodInterceptor
{
    public function invoke(MethodInvocation $invocation)
    {
        $today = getdate();
        if ($today['weekday'][0] === 'S') {
            throw new \RuntimeException(
                $invocation->getMethod()->getName() . " not allowed on weekends!"
            );
        }
        return $invocation->proceed();
    }
}
```

Finally, we configure everything. In this case we match any class, but only the methods with our `#[NotOnWeekends]` attribute:

```php

use Ray\Di\AbstractModule;

class WeekendModule extends AbstractModule
{
    protected function configure()
    {
        $this->bind(BillingServiceInterface::class)->to(BillingService::class);
        $this->bindInterceptor(
            $this->matcher->any(),                           // any class
            $this->matcher->annotatedWith('NotOnWeekends'),  // #[NotOnWeekends] attributed method
            [WeekendBlocker::class]                          // apply WeekendBlocker interceptor
        );
    }
}

$injector = new Injector(new WeekendModule);
$billing = $injector->getInstance(BillingServiceInterface::class);
try {
    echo $billing->chargeOrder();
} catch (\RuntimeException $e) {
    echo $e->getMessage() . "\n";
    exit(1);
}
```
Putting it all together, (and waiting until Saturday), we see the method is intercepted and our order is rejected:

```php
RuntimeException: chargeOrder not allowed on weekends! in /apps/pizza/WeekendBlocker.php on line 14

Call Stack:
    0.0022     228296   1. {main}() /apps/pizza/main.php:0
    0.0054     317424   2. Ray\Aop\Weaver->chargeOrder() /apps/pizza/main.php:14
    0.0054     317608   3. Ray\Aop\Weaver->__call() /libs/Ray.Aop/src/Weaver.php:14
    0.0055     318384   4. Ray\Aop\ReflectiveMethodInvocation->proceed() /libs/Ray.Aop/src/Weaver.php:68
    0.0056     318784   5. Ray\Aop\Sample\WeekendBlocker->invoke() /libs/Ray.Aop/src/ReflectiveMethodInvocation.php:65
```

## Disable interceptors

To disable the interceptor, bind NullInterceptor.

```php
use Ray\Aop\NullInterceptor;

protected function configure()
{
    // ...
    $this->bind(LoggerInterface::class)->to(NullInterceptor::class);
}
```

## Limitations

Behind the scenes, method interception is implemented by generating bytecode at
runtime. Ray.Di dynamically creates a subclass that applies interceptors by
overriding methods. 

This approach imposes limits on what classes and methods can be intercepted:

*   Classes must be non-final
*   Methods must be public
*   Methods must be non-final
*   Instances must be created by Ray.Di. 

## AOP Alliance

The method interceptor API implemented by Ray.Di is mostly same as  a public
specification called [AOP Alliance in Java](http://aopalliance.sourceforge.net/).

# Injecting Providers

With normal dependency injection, each type gets exactly *one instance* of each
of its dependent types. The `RealBillingService` gets one `CreditCardProcessor`
and one `TransactionLog`. Sometimes you want more than one instance of your
dependent types. When this flexibility is necessary, Ray.Di binds a provider.
Providers produce a value when the `get()` method is invoked:

```php
/**
 * @template T
 */
interface ProviderInterface
{
    /**
     * @return T
     */
    public function get();
}
```

The type provided by the provider is specified by the `#[Set]` attribute.

```php
class RealBillingService implements BillingServiceInterface
{
    /**
     * @param ProviderInterface<TransactionLogInterface>      $processorProvider
     * @param ProviderInterface<CreditCardProcessorInterface> $transactionLogProvider
     */
    public __construct(
        #[Set(TransactionLogInterface::class)] private ProviderInterface $processorProvider,
        #[Set(CreditCardProcessorInterface::class)] private ProviderInterface $transactionLogProvider
    ) {}

    public chargeOrder(PizzaOrder $order, CreditCard $creditCard): Receipt
    {
        $transactionLog = $this->transactionLogProvider->get();
        $processor = $this->processorProvider->get();
        
        /* use the processor and transaction log here */
    }
}
```

To support generics in static analysis, you need to set `@param` in phpdoc to `ProviderInterface<TransactionLogInterface>` or `ProviderInterface<Cre ditCardProcessorInterface>` and so on. The type of the instance obtained by the `get()` method is specified and checked by static analysis.

## Providers for multiple instances

Use providers when you need multiple instances of the same type. Suppose your
application saves a summary entry and a details when a pizza charge fails. With
providers, you can get a new entry whenever you need one:

```php
class LogFileTransactionLog implements TransactionLogInterface
{
    public function __construct(
        #[Set(TransactionLogInterface::class)] private readonly ProviderInterface $logFileProvider
    ) {}
    
    public logChargeResult(ChargeResult $result): void {
        $summaryEntry = $this->logFileProvider->get();
        $summaryEntry->setText("Charge " + (result.wasSuccessful() ? "success" : "failure"));
        $summaryEntry->save();
        
        if (! $result->wasSuccessful()) {
            $detailEntry = $this->logFileProvider->get();
            $detailEntry->setText("Failure result: " + result);
            $detailEntry->save();
        }
    }
}
```

## Providers for lazy loading

If you've got a dependency on a type that is particularly *expensive to
produce*, you can use providers to defer that work. This is especially useful
when you don't always need the dependency:

```php
class LogFileTransactionLog implements TransactionLogInterface
{
    public function __construct(
        #[Set(Connection::class)] private ProviderInterface $connectionProvider
    ) {}
    
    public function logChargeResult(ChargeResult $result) {
        /* only write failed charges to the database */
        if (! $result->wasSuccessful()) {
            $connection = $connectionProvider->get();
        }
    }
```

## Providers for Mixing Scopes

Directly injecting an object with a _narrower_ scope usually causes unintended
behavior in your application. In the example below, suppose you have a singleton
`ConsoleTransactionLog` that depends on the request-scoped current user. If you
were to inject the user directly into the `ConsoleTransactionLog` constructor,
the user would only be evaluated once for the lifetime of the application. This
behavior isn't correct because the user changes from request to request.
Instead, you should use a Provider. Since Providers produce values on-demand,
they enable you to mix scopes safely:

```php
class ConsoleTransactionLog implements TransactionLogInterface
{
    public function __construct(
        #[Set(User::class)] private readonly ProviderInterface $userProvider
    ) {}
    
    public function logConnectException(UnreachableException $e): void
    {
        $user = $this->userProvider->get();
        echo "Connection failed for " . $user . ": " . $e->getMessage();
    }
}
```

# Multibindings

_Overview of Multibinder, MapBinder_

Multibinder is intended for plugin-type architectures.

## Multibinding

Using `Multibinder` to host plugins.

### Multibinder

Multibindings make it easy to support plugins in your application. Made popular
by [IDEs](https://plugins.jetbrains.com/phpstorm) and [browsers](https://chrome.google.com/webstore/category/extensions), this pattern exposes APIs
for extending the behaviour of an application.

Neither the plugin consumer nor the plugin author need write much setup code for
extensible applications with Ray.Di. Simply define an interface, bind
implementations, and inject sets of implementations! Any module can create a new
Multibinder to contribute bindings to a set of implementations. To illustrate,
we'll use plugins to summarize ugly URIs like `http://bit.ly/1mzgW1` into
something readable on Twitter.

First, we define an interface that plugin authors can implement. This is usually
an interface that lends itself to several implementations. For this example, we
would write a different implementation for each website that we could summarize.

```php
interface UriSummarizerInterface
{
    /**
     * Returns a short summary of the URI, or null if this summarizer doesn't
     * know how to summarize the URI.
     */
    public function summarize(Uri $uri): string;
}
```

Next, we'll get our plugin authors to implement the interface. Here's an
implementation that shortens Flickr photo URLs:

```php
class FlickrPhotoSummarizer implements UriSummarizer
{
    public function __construct(
        private readonly PhotoPaternMatcherInterface $matcher
    ) {}

    public function summarize(Uri $uri): ?string
    {
        $match = $this->matcher->match($uri);
        if (! $match) {
            return null;
        }
        $id = $this->matcher->group(1);
        $photo = Photo::loockup($id);

        return $photo->getTitle();
    }
  }
}
```

The plugin author registers their implementation using a multibinder. Some
plugins may bind multiple implementations, or implementations of several
extension-point interfaces.

```php
class FlickrPluginModule extends AbstractModule
{
    public function configure(): void 
    {
        $uriBinder = Multibinder::newInstance($this, UriSummarizerInterface::class);
        $uriBinder->addBinding()->to(FlickrPhotoSummarizer::class);

        // ...bind plugin dependencies, such as our Flickr API key
   }
}
```

Now we can consume the services exposed by our plugins. In this case, we're
summarizing tweets:

```php
class TweetPrettifier
{
    /**
     * @param Map<UriSummarizerInterface> $summarizers
     */
    public function __construct(
        #[Set(UriSummarizer::class)] private readonyl Map $summarizers;
        private readonly EmoticonImagifier $emoticonImagifier;
    ) {}
    
    public function prettifyTweet(String tweetMessage): Html
    {
        // split out the URIs and call prettifyUri() for each
    }

    public function prettifyUri(Uri $uri): string
    {
        // loop through the implementations, looking for one that supports this URI
        foreach ($this->summarizer as summarizer) {
            $summary = $summarizer->summarize($uri);
            if ($summary != null) {
                return $summary;
            }
       }

        // no summarizer found, just return the URI itself
        return $uri->toString();
    }
}
```

_**Note:** The method `Multibinder::newInstance($module, $type)` can be confusing.
This operation creates a new binder, but doesn't override any existing bindings.
A binder created this way contributes to the existing Set of implementations for
that type. It would create a new set only if one is not already bound._

Finally we must register the plugins themselves. The simplest mechanism to do so
is to list them programatically:

```php
class PrettyTweets
{
    public function __invoke(): void
    {
        $injector = new Injector(
            new GoogleMapsPluginModule(),
            new BitlyPluginModule(),
            new FlickrPluginModule()
            // ...      
        );

        $injector->getInstance(Frontend::class)->start();
  }
}
(new PrettyTweets)();
```

### MapBinder

You can name the classes you add in the multibinder.

```php
class FlickrPluginModule extends AbstractModule
{
    public function configure(): void 
    {
        $uriBinder = Multibinder::newInstance($this, UriSummarizerInterface::class);
        $uriBinder->addBinding('flickr')->to(FlickrPhotoSummarizer::class);

        // ...bind plugin dependencies, such as our Flickr API key
   }
}
```
In the application, you can retrieve a `Map` injected by specifying attributes such as ``#[Set(UriSummarizer::class)]`` with the name as it was when specified by the binding.

```php

class TweetPrettifier
{
    /**
     * @param Map<UriSummarizerInterface> $summarizers
     */
    public function __construct(
        #[Set(UriSummarizer::class)] private readonly Map $summarizers;
    ) {}

    public doSomething(): void
    {
        $filickerSummarizer = $this->summarizers['flicker'];
        assert($filickerSummarizer instanceof FlickrPhotoSummarizer);
    }    
}
```

## Set binding

The `setBinding()` method overrides any previous binding.

```php
$UriBinder = Multibinder::newInstance($this, UriSummarizerInterface::class);
$UriBinder->setBinding('flickr')->(FlickrPhotoSummarizer::class);
```

## Map

`Map` objects are treated as generics in static analysis. If the injected interface is T, it is written as `Map<T>`.

```php
/** @param Map<UriSummarizerInterface> $summarizers **/
```

## Annotation

Since it is not possible to annotate the argument, annotate the property to be assigned with the same name and annotate the property with `@Set`.

```php
class TweetPrettifier
{
    /** @Set(UriSummarizer::class) */
    private $summarizers;
    
    /**
     * @param Map<UriSummarizerInterface> $summarizers
     */
    public function __construct(Map $summarizers) {
        $this->summarizers = $summarizers;
    }
}
```

# Contextual Provider Bindings

You may want to create an object using the context when binding with Provider. For example, you want to inject different connection destinations on the same DB interface. In such a case, we bind it by specifying the context (string) with `toProvider ()`.


```php
$dbConfig = ['user' => $userDsn, 'job'=> $jobDsn, 'log' => $logDsn];
$this->bind()->annotatedWith('db_config')->toInstance(dbConfig);
$this->bind(Connection::class)->annotatedWith('usr_db')->toProvider(DbalProvider::class, 'user');
$this->bind(Connection::class)->annotatedWith('job_db')->toProvider(DbalProvider::class, 'job');
$this->bind(Connection::class)->annotatedWith('log_db')->toProvider(DbalProvider::class, 'log');
```

Providers are created for each context.

```php
use Ray\Di\Di\Inject;
use Ray\Di\Di\Named;

class DbalProvider implements ProviderInterface, SetContextInterface
{
    private $dbConfigs;

    public function setContext($context)
    {
        $this->context = $context;
    }

    public function __construct(#[Named('db_config') array $dbConfigs)
    {
        $this->dbConfigs = $dbConfigs;
    }

    /**
     * {@inheritdoc}
     */
    public function get()
    {
        $config = $this->dbConfigs[$this->context];
        $conn = DriverManager::getConnection($config);

        return $conn;
    }
}
```

It is the same interface, but you can receive different connections made by `Provider`.

```php
public function __construct(
    #[Named('user')] private readonly Connection $userDb,
    #[Named('job')] private readonly Connection $jobDb,
    #[Named('log') private readonly Connection $logDb)
) {}
```

# Object Life Cycle

`#[PostConstruct]` is used on methods that need to get executed after dependency injection has finalized to perform any extra initialization.

```php
use Ray\Di\Di\PostConstruct;
```
```php
#[PostConstruct]
public function init()
{
    //....
}
```

# Ray.Di Best Practices

*   [Minimize mutability](bp/minimize_mutability.html)
*   [Inject only direct dependencies](bp/inject_only_direct_dependencies.html)
*   [Use the Injector as little as possible (preferably only once)](bp/injecting_the_injector.html)
*   Avoid cyclic dependencies
*   [Avoid static state](bp/avoid_static_state.html)
*   [Modules should be fast and side-effect free](bp/modules_should_be_fast_and_side_effect_free.html)
*   [Avoid conditional logic in modules](bp/avoid_conditional_logic_in_modules.html)
*   [Don't reuse binding attributes (aka `#[Qualifiers]`)](bp/dont_reuse_annotations.html)
*   [Organize modules by feature, not by class type](bp/organize_modules_by_feature.html)
*   [Document the public bindings provided by modules](bp/document_public_bindings.html)

# Minimize mutability

Wherever possible, use constructor injection to create immutable objects.
Immutable objects are simple, shareable, and can be composed. Follow this
pattern to define your injectable types:

```php
class RealPaymentService implements PaymentServiceInterface
{
    public function __construct(
        private readnonly PaymentQueue $paymentQueue,
        private readnonly Notifier $notifier;
    ){}
```

All fields of this class are readonly and initialized by a constructor.

## Injecting methods

*Constructor injection* has some limitations:

*   Injected constructors may not be optional.
*   It cannot be used unless objects are created by Ray.Di.
*   Subclasses must call `parent()` with all dependencies. This makes constructor
    injection cumbersome, especially as the injected base class changes.

*Setter injection* is most useful when you need to initialize an instance that
is not constructed by Ray.Di.

# Inject only direct dependencies

Avoid injecting an object only as a means to get at another object. For example, don't inject a `Customer` as a means to get at an `Account`:

```php
class ShowBudgets
{
    private readonly Account $account;

    public function __construct(Customer $customer)
    {
        $this->account = $customer->getPurchasingAccount();
    }
```

Instead, inject the dependency directly. This makes testing easier; the test case doesn't need to concern itself with the customer. Use an `Provider` class to create the binding for `Account` that uses the binding for `Customer`:

```php
class CustomersModule extends AbstractModule
{
    protected function configure()
    {
        $this->bind(Account::class)->toProvider(PurchasingAccountProvider::class);
    }
}

class PurchasingAccountProvider implements ProviderInterface
{
    public function __construct(
        private readonly Customer $customer
    ) {}
    
    public function get(): Account
    {
        return $this->customer->getPurchasingAccount();
    }
}
```

By injecting the dependency directly, our code is simpler.

```php
class ShowBudgets
{
    public function __construct(
        private readonly Account $account
   ) {}
```

# Avoid static state

Static state and testability are enemies. Your tests should be fast and free of
side-effects. But non-constant values held by static fields are a pain to
manage. It's tricky to reliably tear down static singletons that are mocked by
tests, and this interferes with other tests.

Although *static state* is bad, there's nothing wrong with the static *keyword*.
Static classes are okay (preferred even!) and for pure functions (sorting, math,
etc.), static is just fine.

# Organize modules by feature, not by class type

Group bindings into features. Ideally it should be possible to enable/disable an
entire working feature by simply installing or not installing a single module in
the injector.

For example, don't just make a `FiltersModule` that has bindings for all the
classes that implement `Filter` in it, and a `GraphsModule` that has all the
classes that implement `Graph`, etc. Instead, try to organize modules by
feature, for example an `AuthenticationModule` that authenticates requests made
to your server, or a `FooBackendModule` that lets your server make requests to
the Foo backend.

This principle is also known as "organize modules vertically, not horizontally".

# Avoid conditional logic in modules

Itâ€™s tempting to create modules that have moving parts and can be configured to
operate differently for different environments:

```php
class FooModule extends AbstractModule
{
  public function __construct(
    private readonly ?string $fooServer
  }{}

  protected function configure(): void
  {
    if ($this->fooServer != null) {
        $this->bind(String::class)->annotatedWith(ServerName::class)->toInstance($this->fooServer);
        $this->bind(FooService::class)->to(RemoteFooService::class);
    } else {
        $this->bind(FooService::class)->to(InMemoryFooService::class);
    }
  }
}
```

Conditional logic in itself isn't too bad. But problems arise when
configurations are untested. In this example, the`InMemoryFooService` is used
for development and `RemoteFooService` is used in production. But without
testing this specific case, it's impossible to be sure that `RemoteFooService`
works in the integrated application.

To overcome this, **minimize the number of distinct configurations** in your
applications. If you split production and development into distinct modules, it
is easier to be sure that the entire production codepath is tested. In this
case, we split `FooModule` into `RemoteFooModule` and `InMemoryFooModule`. This
also prevents production classes from having a compile-time dependency on test
code.

Another, related, issue with the example above: sometimes there's a binding for
`#[ServerName]`, and sometimes that binding is not there. You should avoid
sometimes binding a key, and other times not.

# Modules should be fast and side-effect free

Rather than using an external XML file for configuration, Ray.Di modules are written using regular PHP code. PHP is familiar, works with your IDE, and survives refactoring.

But the full power of the PHP language comes at a cost: it's easy to do _too much_ in a module. It's tempting to connect to a database connection or to start an HTTP server in your Ray.Di module. Don't do this! Doing heavy-lifting in a module poses problems:

*   **Modules start up, but they don't shut down.** Should you open a database connection in your module, you won't have any hook to close it.
*   **Modules should be tested.** If a module opens a database as a course of execution, it becomes difficult to write unit tests for it.
*   **Modules can be overridden.** Ray.Di modules support `overrides`, allowing a production service to be substituted with a lightweight or test one. When the production service is created as a part of module execution, such overrides are ineffective.

Rather than doing work in the module itself, define an interface that can do the work at the proper level of abstraction. In our applications we use this interface:

```php
interface ServiceInterface
{
    /**
     * Starts the service. This method blocks until the service has completely started.
     */
    public function start(): void;
    
    /**
     * Stops the service. This method blocks until the service has completely shut down.
     */
    public function stop(): void;
}
```

After creating the Injector, we finish bootstrapping our application by starting its services. We also add shutdown hooks to cleanly release resources when the application is stopped.

```php
class Main
{
    public function __invoke()
        $injector = new Injector([
            new DatabaseModule(),
            new WebserverModule(),
            // ..
        ]);
        $databaseConnectionPool = $injector->getInstance(ServiceInterface::class, DatabaseService::class);
        $databaseConnectionPool->start();
        $this->addShutdownHook($databaseConnectionPool);

        $webserver = $injector->getInstance(ServiceInterface::class, WebserverService::class);
        $webserver->start();
        $this->addShutdownHook($webserver);
    );
}
```

# Document the public bindings provided by modules

To document a Ray.Di module, a good strategy is to describe the public bindings
that that module installs, for example:

```php
/**
 * Provides FooServiceClient and derived bindings
 *
 * [...]
 *
 * The following bindings are provided:
 *
 *  FooServiceClient
 *  FooServiceClientAuthenticator
 */
final class FooServiceClientModule extends AbstractModule
{
  // ...
}
```

# Don't reuse binding attributes (aka `#[Qualifier]`)

Sometimes, of course, it makes sense to bind some highly-related bindings with the same attributes. E.g. `#[ServerName]`

That said, most binding attributes should only qualify one binding. And you should definitely not reuse a binding attributes for *unrelated* bindings.

When in doubt, don't reuse attributes: creating one is straightfoward!

To avoid some boilerplate, sometimes it makes sense to use attribute parameters to create distinct annotation instances from a single declaration. For example:

```php
enum Thing
{
    case FOO;
    case BAR;
    case BAZ;
}

#[Attribute, \Ray\Di\Di\Qualifier]
final class MyThing
{
    public function __construct(
        public readonly Thing $value
    ) {}
}
```

You can then use `#[MyThing(Thing::FOO)]`, `#[MyThing(Thing::BAR)]`, and `#[MyThing(Thing::BAZ)]` rather than defining each of them as separate attribute types.

# Use the Injector as little as possible (preferably only once)

Ray.Di has a [built-in](../built_in_bindings.html) binding for the `Injector` but it should be used sparsely.

Don't pass injectors into other injected objects through the constructor (which is also called "injecting the injector"). You should declare your dependencies statically.

By injecting the injector, Ray.Di will not know in advance if the dependency can be resolved.
This is because you can get instances directly from the injector.
If the dependencies are not set up correctly and the injector is not injected, the dependency resolution failure can be detected in the compilation of Ray.Di.
However, if you are injecting an injector, Ray.Di may raise an `Unbound` exception at runtime (when the code executes `getInstance()` lazily) and the dependency resolution may fail.

# Avoid Circular Dependencies

## What are circular dependencies?

Say that your application has a few classes including a `Store`, a `Boss`, and a
`Clerk`.

```java
public class Store {
  private final Boss boss;
  //...

  @Inject public Store(Boss boss) {
     this.boss = boss;
     //...
  }

  public void incomingCustomer(Customer customer) {...}
  public Customer getNextCustomer() {...}
}

public class Boss {
  private final Clerk clerk;
  @Inject public Boss(Clerk clerk) {
    this.clerk = clerk;
  }
}

public class Clerk {
  // Nothing interesting here
}
```

Right now, the dependency chain is all good: constructing a `Store` results in
constructing a `Boss`, which results in constructing a `Clerk`. However, to get
the `Clerk` to get a `Customer` to do the selling, it will need a reference to
the `Store` to get those customer:

```java
public class Store {
  private final Boss boss;
  //...

  @Inject public Store(Boss boss) {
     this.boss = boss;
     //...
  }
  public void incomingCustomer(Customer customer) {...}
  public Customer getNextCustomer() {...}
}

public class Boss {
  private final Clerk clerk;
  @Inject public Boss(Clerk clerk) {
    this.clerk = clerk;
  }
}

public class Clerk {
  private final Store shop;
  @Inject Clerk(Store shop) {
    this.shop = shop;
  }

  void doSale() {
    Customer sucker = shop.getNextCustomer();
    //...
  }
}
```

which leads to a cycle: `Clerk` -> `Store` -> `Boss` -> `Clerk`. In trying to
construct a `Clerk`, an `Store` will be constructed, which needs a `Boss`, which
needs a `Clerk` again!

## Ways to avoid circular dependencies

### Eliminate the cycle (Recommended)

Cycles often reflect insufficiently granular decomposition. To eliminate such
cycles, extract the Dependency Case into a separate class.

Take the above `Store` example, the work of managing the incoming customers can
be extracted into another class, say `CustomerLine`, and that can be injected
into the `Clerk` and `Store`.

```java
public class Store {
  private final Boss boss;
  private final CustomerLine line;
  //...

  @Inject public Store(Boss boss, CustomerLine line) {
     this.boss = boss;
     this.line = line;
     //...
  }

  public void incomingCustomer(Customer customer) { line.add(customer); }
}

public class Clerk {
  private final CustomerLine line;

  @Inject Clerk(CustomerLine line) {
    this.line = line;
  }

  void doSale() {
    Customer sucker = line.getNextCustomer();
    //...
  }
}
```

While both `Store` and `Clerk` depend on the `CustomerLine`, there's no cycle in
the dependency graph (although you may want to make sure that the `Store` and
`Clerk` both use the same `CustomerLine` instance). This also means that your
`Clerk` will be able to sell cars when your shop has a big tent sale: just
inject a different `CustomerLine`.

### Break the cycle with a Provider

[Injecting a Guice provider](InjectingProviders)
will allow you to add a _seam_ in the dependency graph. The `Clerk` will still
depend on the `Store`, but the `Clerk` doesn't look at the `Store` until it
needs a `Store`.

```java
public class Clerk {
  private final Provider<Store> shopProvider;
  @Inject Clerk(Provider<Store> shopProvider) {
    this.shopProvider = shopProvider;
  }

  void doSale() {
    Customer sucker = shopProvider.get().getNextCustomer();
    //...
  }
}
```

Note here, that unless `Store` is bound as a
[`Singleton`](Scopes#singleton) or in some
other scope to be reused, the `shopProvider.get()` call will end up constructing
a new `Store`, which will construct a new `Boss`, which will construct a new
`Clerk` again!

### Use factory methods to tie two objects together

When your dependencies are tied together a bit closer, untangling them with the
above methods won't work. Situations like this come up when using something like
a [View/Presenter](https://en.wikipedia.org/wiki/Model-view-presenter) paradigm:

```java
public class FooPresenter {
  @Inject public FooPresenter(FooView view) {
    //...
  }

  public void doSomething() {
    view.doSomethingCool();
  }
}

public class FooView {
  @Inject public FooView(FooPresenter presenter) {
    //...
  }

  public void userDidSomething() {
    presenter.theyDidSomething();
  }
  //...
}
```

Each of those objects needs the other object. Here, you can use
[AssistedInject](AssistedInject) to get
around it:

```java
public class FooPresenter {
  private final FooView view;
  @Inject public FooPresenter(FooView.Factory viewMaker) {
    view = viewMaker.create(this);
  }

  public void doSomething() {
  //...
    view.doSomethingCool();
  }
}

public class FooView {
  @Inject public FooView(@Assisted FooPresenter presenter) {...}

  public void userDidSomething() {
    presenter.theyDidSomething();
  }

  public static interface Factory {
    FooView create(FooPresenter presenter)
  }
}
```

Such situations also come up when attempting to use Guice to manifest business
object models, which may have cycles that reflect different types of
relationships.
[AssistedInject](AssistedInject) is also
quite good for such cases.

## Circular proxy feature

In cases where one of the dependencies in the circular chain is an interface
type, Guice can work around the circular dependency chain by generating a proxy
at runtime to break the cycle. However, this support is really limited and can
break unexpectedly if the type is changed to a non-interface type.

To prevent unexpected circular dependency chains in your code, we recommend that
you disable Guice's circular proxy feature. To do so, install a module that
calls `binder().disableCircularProxies()`:

```java {.good}
final class ApplicationModule extends AbstractModule {
  @Override
  protected void configure() {
    ...

    binder().disableCircularProxies();
  }
}
```

TIP: You can also install `Modules.disableCircularProxiesModule()` to disable
circular proxy in Guice.
